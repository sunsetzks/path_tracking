==============
Hybrid A* Path Planning
==============

A comprehensive implementation of the Hybrid A* path planning algorithm for autonomous vehicles.

Features
--------

* **Hybrid A* Algorithm**: Combines the efficiency of A* with continuous vehicle motion
* **Vehicle Kinematics**: Uses bicycle model with realistic steering constraints
* **Multi-objective Cost Function**:
  - Steering angle cost
  - Turning cost (yaw changes)
  - Cusp cost (direction changes)
  - Path smoothness cost
  - Obstacle avoidance cost
* **Forward Simulation**: Considers steering angle velocity in motion prediction
* **Flexible Configuration**: Adjustable parameters for different scenarios
* **Visualization**: Built-in path visualization with matplotlib

Installation
------------

.. code-block:: bash

    cd astar_project
    pip install -e .

Or using poetry:

.. code-block:: bash

    poetry install

Quick Start
-----------

.. code-block:: python

    from astar_project.hybrid_astar import HybridAStar, VehicleModel, State, DirectionMode
    import numpy as np

    # Create vehicle model
    vehicle = VehicleModel(wheelbase=2.5, max_steer=np.pi/4)
    
    # Create planner
    planner = HybridAStar(
        vehicle_model=vehicle,
        grid_resolution=0.5,
        velocity=2.0,
        simulation_time=0.5
    )
    
    # Define start and goal
    start = State(x=0, y=0, yaw=0, direction=DirectionMode.FORWARD)
    goal = State(x=10, y=10, yaw=np.pi/2, direction=DirectionMode.FORWARD)
    
    # Plan path
    path = planner.plan_path(start, goal)
    
    if path:
        planner.visualize_path(path, start, goal)

Algorithm Details
-----------------

**Hybrid A* Algorithm**

The Hybrid A* algorithm extends the traditional A* algorithm to continuous space, making it suitable for vehicle path planning. Key components:

1. **State Space**: (x, y, yaw, direction, steering_angle)
2. **Motion Primitives**: Generated using forward simulation with different steering rates
3. **Cost Function**: Multi-objective function balancing multiple factors
4. **Search Strategy**: Best-first search with admissible heuristic

**Vehicle Model**

Uses a bicycle model for vehicle kinematics:

.. math::

    \dot{x} = v \cos(\psi)
    \dot{y} = v \sin(\psi)
    \dot{\psi} = \frac{v \tan(\delta)}{L}

Where:
- (x, y): Vehicle position
- ψ: Vehicle heading angle
- v: Linear velocity
- δ: Steering angle
- L: Wheelbase

**Cost Function**

The total cost combines multiple objectives:

.. math::

    f(n) = g(n) + h(n)

Where g(n) includes:
- Motion cost (distance traveled)
- Steering angle cost: :math:`w_s |\delta| / \delta_{max}`
- Turning cost: :math:`w_t |\Delta\psi|`
- Cusp cost: :math:`w_c` (when direction changes)
- Path smoothness cost: :math:`w_p \sum |\Delta\kappa|`

**Forward Simulation**

Motion primitives are generated by forward simulation:

1. Apply constant steering rate for simulation time
2. Integrate vehicle dynamics using discrete time steps
3. Check collision along the entire trajectory
4. Calculate associated costs

Configuration Parameters
------------------------

**Vehicle Parameters**:
- ``wheelbase``: Distance between axles (default: 2.5m)
- ``max_steer``: Maximum steering angle (default: π/4 rad)

**Planning Parameters**:
- ``grid_resolution``: Spatial discretization (default: 1.0m)
- ``angle_resolution``: Angular discretization (default: π/8 rad)
- ``velocity``: Forward simulation velocity (default: 2.0 m/s)
- ``simulation_time``: Motion primitive duration (default: 1.0s)

**Cost Weights**:
- ``w_steer``: Steering angle penalty (default: 10.0)
- ``w_turn``: Turning penalty (default: 15.0)
- ``w_cusp``: Direction change penalty (default: 50.0)
- ``w_path``: Path smoothness penalty (default: 5.0)

Examples and Demos
------------------

Run the demonstration script:

.. code-block:: bash

    python -m astar_project.demo

This will show three scenarios:
1. **Basic Navigation**: Navigate around obstacles
2. **Parallel Parking**: Tight maneuvering demonstration
3. **U-Turn**: Direction reversal in confined space

Testing
-------

Run the test suite:

.. code-block:: bash

    pytest tests/

Or with poetry:

.. code-block:: bash

    poetry run pytest

Applications
------------

This implementation is suitable for:

* **Autonomous Vehicle Path Planning**
* **Robot Navigation**
* **Parking Assistance Systems**
* **Motion Planning Research**
* **Robotics Education**

Performance Considerations
--------------------------

* **Grid Resolution**: Finer resolution improves path quality but increases computation
* **Simulation Time**: Longer simulation enables smoother paths but may increase search space
* **Cost Weights**: Tuning weights balances different objectives (smoothness vs efficiency)
* **Max Iterations**: Limits search time but may prevent finding solutions

Advanced Usage
--------------

**Custom Obstacle Maps**:

.. code-block:: python

    import numpy as np
    
    # Create obstacle map (1 = obstacle, 0 = free)
    obstacle_map = np.zeros((50, 50))
    obstacle_map[20:30, 15:25] = 1  # Add rectangular obstacle
    
    planner.set_obstacle_map(obstacle_map, origin_x=-10, origin_y=-10)

**Parameter Tuning**:

.. code-block:: python

    # For tight spaces (parking)
    planner.w_steer = 5.0    # Lower steering penalty
    planner.w_cusp = 30.0    # Allow more reversing
    
    # For highway driving
    planner.w_steer = 15.0   # Higher steering penalty
    planner.w_path = 10.0    # Emphasize smoothness

**Performance Analysis**:

.. code-block:: python

    from astar_project.demo import analyze_path_quality
    
    path = planner.plan_path(start, goal)
    if path:
        analyze_path_quality(path)

License
-------

MIT License - see LICENSE file for details.

Contributing
------------

Contributions are welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Ensure all tests pass
5. Submit a pull request

Authors
-------

* **Your Name** - Initial implementation
